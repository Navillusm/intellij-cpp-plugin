{
parserClass="com.cppPlugin.parser.CppParser"
stubParserClass="com.cppPlugin.parser.GeneratedParserUtilBase"
extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
psiClassPrefix="Cpp"
psiImplClassSuffix="Impl"
psiPackage="com.cppPlugin.psi"
psiImplPackage="com.cppPlugin.psi.impl"
elementTypeHolderClass="com.cppPlugin.psi.CppTypes"
elementTypeClass="com.cppPlugin.psi.CppElementType"
tokenTypeClass="com.cppPlugin.psi.CppTokenType"
}

hexQuad ::= hexDigit hexDigit hexDigit hexDigit
universalCharacterName ::= "\u" hexQuad | "\U" hexQuad hexQuad
preProcessingToken ::= headerName | identifier | ppNumber | characterLiteral | stringLiteral | preProcessingOpOrPunc | userDefinedCharacterLiteral | userDefinedStringLiteral
token ::= identifier | keyword | literal | operatorToken | punctuator
headerName ::= '<' hCharSequence '>' | '"' qCharSequence '"'
hCharSequence ::= hChar*
hChar ::= //any char that is not a > or newline
qCharSequence ::= qChar*
qChar ::= //any char that is not a " or newline
ppNumber ::= '.'? digit (digit | identifierNonDigit | 'e' sign | 'E' sign | '.')*
identifier ::= identifierNonDigit (identifierNonDigit | identifier digit)*
identifierNonDigit ::= nonDigit | universalCharacterName
nonDigit ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '_'
digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
keyword ::= "alignas" | "alignof" | "asm" |"auto" | "bool" | "break" | "case" | "catch" | "char" | "char16_t" | "char32_t" | "class" | "const" | "constexpr" | "const_cast" | "continue" | "decltype" | "default" | "delete" | "do" | "double" | "dynamic_cast" | "else" | "enum" | "explicit" | "export" | "extern" | "false" | "float" | "for" | "friend" | "goto" | "if" | "inline" | "int" | "long" | "mutable" | "namespace" | "new" | "noexcept" | "nullptr" | "operator" | "private" | "protected" | "public" | "register" | "reinterpret_cast" | "return" | "short" | "signed" | "sizeof" | "static" | "static_assert" | "static_cast" | "struct" | "switch" | "template" | "this" | "thread_local" | "throw" | "true" | "try" | "typedef" | "typeid" | "typename" | "union" | "unsigned" | "using" | "virtual" | "void" | "volatile" | "wchar_t" | "while"
operatorToken ::=  preProcessingOpOrPunc
punctuator ::= preProcessingOpOrPunc
preProcessingOpOrPunc ::= "{" | "}" | "[" | "]" | "#" | "##" | "(" | ")" | "<:" | ":>" | "<%" | "%>" | "%:" | "%:%:" | ";" | ":" | "..." | "new" | "delete" | "?" | "::" | "." | ".*" | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | "<<=" | ">>=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | "and" | "and_eq" | "bitand" | "bitor" | "compl" | "not" | "not_eq" | "or" | "or_eq" | "xor" | "xor_eq"
literal ::= integerLiteral | characterLiteral | floatingLiteral | stringLiteral | booleanLiteral | pointerLiteral | userDefinedLiteral
integerLiteral ::= decimalLiteral integerSuffix? | octalLiteral integerSuffix? | hexadecimalLiteral integerSuffix?
decimalLiteral ::= digitWithOutZero digit*
octalLiteral ::= '0' octDigit*
hexadecimalLiteral ::= '0' ('x' | 'X') hexDigit*
digitWithOutZero ::= '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
octDigit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
hexDigit ::= digit | 'A' | 'B' | 'C' | 'D' | 'E' |'F'
integerSuffix ::= unsignedSuffix longSuffix? | unsignedSuffix longLongSuffix | longSuffix unsignedSuffix | longLongSuffix unsignedSuffix
unsignedSuffix ::= 'u' | 'U'
longSuffix ::= 'l' | 'L'
longLongSuffix ::= 'll' | 'LL'
characterLiteral ::= ('u' | 'U' | 'L')? "'" cCharSequence "'"
cCharSequence ::= cChar*
cChar ::= escapeSequence | universalCharacterName //+ any char that is not ' or \ or newline
escapeSequence ::=  simpleEscapeSequence | octalEscapeSequence | hexadecimalEscapeSequence
simpleEscapeSequence ::= "\'" | "\"" | "\?" | "\\" | "\a" | "\b" | "\f" | "\n" | "\r" | "\t" | "\v"
octalEscapeSequence ::= "\\" octDigit octDigit? octDigit?
hexadecimalEscapeSequence ::= "\x" hexDigit*
floatingLiteral ::= fractionalConstant exponentPart? floatingSuffix?
fractionalConstant ::= digitSequence? "." digitSequence | digitSequence "."
exponentPart ::= ('e' | 'E') sign? digitSequence
sign ::= '+' | '-'
digitSequence ::= digit*
floatingSuffix ::= 'f' | 'l' | 'F' | 'L'
stringLiteral ::= encodingPrefix? ('"' sCharSequence? '"' | 'R' rawString)
encodingPrefix ::= "u8" | "u" | "U" | "L"
sCharSequence ::= sChar*
sChar ::= escapeSequence | universalCharacterName //+ any char that is not " \ or newline
rawString ::= '"' dCharSequence? '(' rCharSequence? ')' dCharSequence? '"'
rCharSequence ::= rChar*
rChar ::= //any character except ) followed by dChars followed by "
dCharSequence ::= dChar*
dChar ::= //any character except ( ) \  space, horizontal tab, vertical tab, form feed, and newline
booleanLiteral ::= "true" | "false"
pointerLiteral ::= "nullptr"
userDefinedLiteral ::= userDefinedCharacterLiteral | userDefinedStringLiteral | userDefinedIntegerLiteral | userDefinedFloatingLiteral
userDefinedStringLiteral ::= stringLiteral userDefinedSuffix
userDefinedCharacterLiteral ::= characterLiteral userDefinedSuffix
userDefinedIntegerLiteral ::= (decimalLiteral | octalLiteral | hexadecimalLiteral) userDefinedSuffix
userDefinedFloatingLiteral ::= fractionalConstant exponentPart? userDefinedSuffix | digitSequence exponentPart userDefinedSuffix
userDefinedSuffix ::= identifier
translationUnit ::= declarationSequence?
primaryExpression ::= literal | 'this' | "(" expression ")" | idExpression | lambdaExpression
idExpression ::= unqualifiedId | qualifiedId
unqualifiedId ::= identifier | operatorFunctionId | conversionFunctionId | literatOperatorId | '~' className | '~' decltypeSpecifier | templateId
qualifiedId ::= "::"? nestedNameSpecifier "template"? unqualifiedId | "::" (identifier | operatorFunctionId | literatOperatorId | templateId)
nestedNameSpecifier ::= typeName "::" | namespaceName "::" | decltypeSpecifier "::" (identifier "::" | "template"? simpleTemplateId "::")?
lambdaExpression ::= lambdaIntroducer lambdaDeclarator? compoundStatement
lambdaIntroducer ::= "[" lambdaCapture "]"
lambdaCapture ::= captureDefault | captureList | captureDefault "," captureList
captureDefault ::= "&" | "="
captureList ::= capture "..."? ("," capture "..."?)*
capture ::= "&"? identifier | "this"
lambdaDeclarator ::= "(" parameterDeclarationClause ")" "mutable"? exceptionSpecification? attributeSpecifierSeq? trailingReturnType?
postfixExpression ::= (primaryExpression | (typeNameSpecifier | simpleTypeSpecifier) bracedInitList | (typeNameSpecifier | simpleTypeSpecifier) "(" expressionList? ")" | ("const" | "dynamic" | "static" | "reinterpret") "_cast<" typeId ">(" expression ")" | "typeid(" (expression | typeId) ")" ) ("[" expression "]" | "[" bracedInitList? "]" | "(" expressionList? ")" | "." "template"? idExpression | "->" "template"? idExpression | "->" pseudoDestructorName | "." pseudoDestructorName | "++" | "--")*
expressionList ::= initializerList
pseudoDestructorName ::= "::"? nestedNameSpecifier? typeName "::" "~" typeName | "::"? nestedNameSpecifier "template" simpleTemplateId "::" "~" typeName | "::"? nestedNameSpecifier? "~" typeName | "~" decltypeSpecifier
unaryExpression ::= postfixExpression | ("++" | "--") castExpression | unaryOperator castExpression | "sizeof" (unaryExpression | "(" typeId ")" | "..." "(" identifier ")") | "alignof" "(" typeId ")" | noExceptExpression | newExpression | deleteExpression
unaryOperator ::= '*' | '&' | '+' | '-' | '!' | '~'
newExpression ::= "::"? "new" newPlacement? (newTypeId | "(" typeId ")") newInitializer?
newPlacement ::= "(" expressionList ")"
newTypeId ::= typeSpecifierSeq newDeclarator?
newDeclarator ::= ptrOperator newDeclarator? | noPtrNewDeclarator
noPtrNewDeclarator ::= "[" expression "]" attributeSpecifierSeq? ("[" constantExpression "]" attributeSpecifierSeq?)*
newInitializer ::= "(" expressionList? ")" | bracedInitList
deleteExpression ::= "::"? "delete" "[]"? castExpression
noExceptExpression ::= "noexcept" "(" expression ")"
castExpression ::= ( "(" typeId ")" )* unaryExpression
pmExpression ::= castExpression ((".*" | "->*") castExpression)*
multiplicativeExpression ::= pmExpression (('*' | '/' | '%') pmExpression)*
additiveExpression ::= multiplicativeExpression (('+' | '-') multiplicativeExpression)*
shiftExpression ::= additiveExpression (("<<" | ">>") additiveExpression)*
relationalExpression ::= shiftExpression (('<' | '>' | '>=' | '<=') shiftExpression)*
equalityExpression ::= relationalExpression (("==" | "!=") relationalExpression)*
andExpression ::= equalityExpression ('&' equalityExpression)*
exclusiveOrExpression ::= andExpression ('^' andExpression)*
inclusiveOrExpression ::= exclusiveOrExpression ('|' exclusiveOrExpression)*
logicalAndExpression ::= inclusiveOrExpression ('&&' inclusiveOrExpression)*
logicalOrExpression ::= logicalAndExpression ('||' logicalAndExpression)*
conditionalExpression ::= logicalOrExpression | logicalOrExpression '?' expression ':' assignmentExpression
assignmentExpression ::= conditionalExpression | logicalOrExpression assignmentOperator initializerClause | throwExpression
assignmentOperator ::= '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '>>=' | '<<=' | '&=' | '^=' | '|='
expression ::= assignmentExpression (',' assignmentExpression)*
constantExpression ::= conditionalExpression
statement ::= labeledStatement | attributeSpecifierSeq? (expressionStatement | compoundStatement | selectionStatement | iterationStatement | jumpStatement | tryBlock) | declarationStatement
labeledStatement ::= attributeSpecifierSeq? (identifier ':' statement | "case" constantExpression ':' statement | "default" ':' statement)
expressionStatement ::= expression? ';'
compoundStatement ::= '{' statementSeq '}'
statementSeq ::= statement*
selectionStatement ::= "if" "(" condition ")" statement ("else" statement)* | "switch" "(" condition ")" statement
condition ::= expression | attributeSpecifierSeq? declSpecifierSeq declarator ('=' initializerClause | bracedInitList)
iterationStatement ::= 'while' '(' condition ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'for' '(' forInitStatement condition? ';' expression? ')' statement | 'for' '(' forRangeDeclaration ':' forRangeInitializer ')' statement
forInitStatement ::= expressionStatement | simpleDeclaration
forRangeDeclaration ::= attributeSpecifierSeq? typeSpecifierSeq declarator
forRangeInitializer ::= expression bracedInitList
jumpStatement ::= ("break" | "continue" | "return" (expression | bracedInitList?) | "goto" identifier) ';'
declarationStatement ::= blockDeclaration
declarationSequence ::= declaration* declaration
declaration ::= blockDeclaration | functionDefinition | templateDeclaration | explicitInstantiation | explicitSpecialization | linkageSpecification | namespaceDefinition | emptyDeclaration | attributeDeclaration
blockDeclaration ::= simpleDeclaration | asmDefinition | namespaceAliasDefinition | usingDeclaration | usingDirective | staticAssertDeclaration | opaqueEnumDeclaration
aliasDeclaration ::= "using" identifier '=' typeId ';'
simpleDeclaration ::= attributeSpecifierSeq? declSpecifierSeq? initDeclaratorList? ';'
staticAssertDeclaration ::= "static_assert" "(" constantExpression ',' stringLiteral ')' ';'
emptyDeclaration ::= ';'
attributeDeclaration ::= attributeSpecifierSeq ';'
declSpecifier ::= storageClassSpecifier | typeSpecifier | functionSpecifier | "friend" | "typedef" | "constexpr"
declSpecifierSeq ::= declSpecifier* attributeSpecifierSeq?
storageClassSpecifier ::= "auto" | "register" | "static" | "thread_local" | "extern" | "mutable"
functionSpecifier ::= "inline" | "virtual" | "explicit"
typedefName ::= identifier
typeSpecifier ::= trailingTypeSpecifier | classSpecifier | enumSpecifier
trailingTypeSpecifier ::= simpleTypeSpecifier | elaboratedTypeSpecifier | typeNameSpecifier | cvQualifier
typeSpecifierSeq ::= typeSpecifier* typeSpecifier attributeSpecifierSeq?
trailingTypeSpecifierSeq ::= trailingTypeSpecifier* attributeSpecifierSeq?
simpleTypeSpecifier ::= '::'? nestedNameSpecifier? typeName | '::'? nestedNameSpecifier "template" simpleTemplateId | 'char' | "char16_t" | "char32_t" | "wchar_t" | "bool" | "short" | "int" | "long" | "signed" | "unsigned" | "float" | "double" | "void" | "auto" | decltypeSpecifier
typeName ::= className | enumName | typedefName | simpleTemplateId
decltypeSpecifier ::= "decltype" "(" expression ")"
elaboratedTypeSpecifier ::= classKey attributeSpecifierSeq? "::"? nestedNameSpecifier? identifier | classKey "::"? nestedNameSpecifier? "template"? simpleTemplateId | "enum" "::"? nestedNameSpecifier? identifier
enumName ::= identifier
enumSpecifier ::= enumHead "{" enumeratorList? "}" | enumHead "{" enumeratorList ',' "}"
enumHead ::= enumKey attributeSpecifierSeq? (nestedNameSpecifier identifier enumBase? | identifier? enumBase?)
opaqueEnumDeclaration ::= enumKey attributeSpecifierSeq? identifier enumBase? ';'
enumKey ::= "enum" ("class" | "struct")?
enumBase ::= ':' typeSpecifierSeq
enumeratorList ::= enumeratorDefinition (',' enumeratorDefinition)*
enumeratorDefinition ::= enumerator ('=' constantExpression)?
enumerator ::= identifier
namespaceName ::= originalNamespaceName | namespaceAlias
originalNamespaceName ::= identifier
namespaceDefinition ::= namedNamespaceDefinition | unnamedNamespaceDefinition
namedNamespaceDefinition ::= originalNamespaceDefinition | extensionNamespaceDefinition
originalNamespaceDefinition ::= "inline"? "namespace" identifier "{" namespaceBody "}"
extensionNamespaceDefinition ::= "inline"? "namespace" originalNamespaceName "{" namespaceBody "}"
unnamedNamespaceDefinition ::= "inline"? "namespace" "{" namespaceBody "}"
namespaceBody ::= declarationSequence
namespaceAlias ::= identifier
namespaceAliasDefinition ::= "namespace" identifier "=" qualifiedNamespaceSpecifier ";"
qualifiedNamespaceSpecifier ::= "::"? nestedNameSpecifier? namespaceName
usingDeclaration ::= "using" "typename"? "::"? nestedNameSpecifier unqualifiedId ';' | "using" "::" unqualifiedId ';'
usingDirective ::= attributeSpecifierSeq? "using" "namespace" "::"? nestedNameSpecifier? namespaceName ';'
asmDefinition ::= "asm" "(" stringLiteral ")" ";"
linkageSpecification ::= "extern" stringLiteral ( "{" declarationSequence? "}" | declaration )
attributeSpecifierSeq ::= attributeSpecifier*
attributeSpecifier ::= "[" "[" attributeList "]" "]" | alignmentSpecifier
alignmentSpecifier ::= "alignas" "(" (typeId | alignmentExpression) "..."? ")"
attributeChunk ::= attribute "..." | attribute?
attributeList ::= (attributeChunk ",")* attributeChunk
attribute ::= attributeToken attributeArgumentClause?
attributeToken ::= identifier | attributeScopedToken
attributeScopedToken ::= attributeNamespace "::" identifier
attributeNamespace ::= identifier
attributeArgumentClause ::= "(" balancedTokenSeq ")"
balancedTokenSeq ::= balancedToken*
balancedToken ::= '(' balancedToken ')' | '[' balancedToken ']' | '{' balancedToken '}' | token
initDeclaratorList ::= (initDeclarator ",")* initDeclarator
initDeclarator ::= declarator initializer
declarator ::= ptrDeclarator | noPtrDeclarator parametersAndQualifiers trailingReturnType
ptrDeclarator ::= ptrOperator* noPtrDeclarator
noPtrDeclarator ::= (declaratorId attributeSpecifierSeq | "(" ptrDeclarator ")") (parametersAndQualifiers | '[' constantExpression? ']' attributeSpecifierSeq?)*
parametersAndQualifiers ::= '(' parameterDeclarationClause ')' attributeSpecifierSeq? cvQualifierSeq? refQualifier? exceptionSpecification?
trailingReturnType ::= "->" trailingTypeSpecifierSeq abstractDeclarator?
ptrOperator ::= '*' attributeSpecifierSeq? cvQualifierSeq? | refQualifier attributeSpecifierSeq? | "::"? nestedNameSpecifier '*' attributeSpecifierSeq? cvQualifierSeq?
cvQualifierSeq ::= cvQualifier*
cvQualifier ::= "const" | "volatile"
refQualifier ::= '&' | '&&'
declaratorId ::= "..."? idExpression | "::"? nestedNameSpecifier? className
typeId ::= typeSpecifierSeq abstractDeclarator?
abstractDeclarator ::= ptrAbstractDeclarator | noPtrAbstractDeclarator? parametersAndQualifiers trailingReturnType | "..."
ptrAbstractDeclarator ::= noPtrAbstractDeclarator | ptrOperator ptrAbstractDeclarator
noPtrAbstractDeclarator ::= ('(' ptrAbstractDeclarator ')' | parametersAndQualifiers) (parametersAndQualifiers | '[' constantExpression ']' attributeSpecifierSeq)*
parameterDeclarationClause ::= parameterDeclarationList ',' '...' | parameterDeclarationList? "..."?
parameterDeclarationList ::= (parameterDeclaration ',')* parameterDeclaration
parameterDeclaration ::= attributeSpecifierSeq? declSpecifierSeq (declarator | abstractDeclarator?) ('=' initializerClause)?
functionDefinition ::= attributeSpecifierSeq? declSpecifierSeq? declarator (functionBody | '=' ('delete' | 'default') ';')
functionBody ::= ctorInitializer? compoundStatement | functionTryBlock
initializer ::= braceOrEqualInitializer | '(' expressionList ')'
braceOrEqualInitializer ::= '=' initializerClause | bracedInitList
initializerClause ::= assignmentExpression | bracedInitList
initializerList ::= (initializerClause "..."? ',') * initializerClause "..."?
bracedInitList ::= "{" initializerList ','? "}"  | '{' '}'
className ::= identifier | simpleTemplateId
classSpecifier ::= classHead '{' memberSpecification? '}'
classHead ::= classKey attributeSpecifierSeq? (classHeadName classVirtSpecifierSeq? baseClause?| baseClause?)
classHeadName ::= nestedNameSpecifier? className
classVirtSpecifierSeq ::= classVirtSpecifier*
classVirtSpecifier ::= "final" | "explicit"
classKey ::= "class" | "struct" | "union"
memberSpecification ::= memberDeclaration memberSpecification? | accessSpecifier ':' memberSpecification?
memberDeclaration ::= attributeSpecifierSeq? declSpecifierSeq? memberDeclaratorList? ';' | functionDefinition ';'? | usingDeclaration | staticAssertDeclaration | templateDeclaration | aliasDeclaration
memberDeclaratorList ::= (memberDeclarator ',')* memberDeclarator
memberDeclarator ::= declarator virtSpecifierSeq? (pureSpecifier | braceOrEqualInitializer?) | identifier? attributeSpecifierSeq? virtSpecifierSeq? ':' constantExpression
virtSpecifierSeq ::= virtSpecifier*
virtSpecifier ::= "override" | "final" | "new"
pureSpecifier ::= "=" "0"
baseClause ::= ':' baseSpecifierList
baseSpecifierList ::= (baseSpecifier "..."? ',')* baseSpecifier "..."?
baseSpecifier ::= attributeSpecifierSeq? baseTypeSpecifier | attributeSpecifierSeq? 'virtual' accessSpecifier? baseTypeSpecifier | attributeSpecifierSeq? accessSpecifier "virtual"? baseTypeSpecifier
classOrDeclType ::= "::"? nestedNameSpecifier? className | decltypeSpecifier
baseTypeSpecifier ::= classOrDeclType
accessSpecifier ::= "private" | "protected" | "public"
conversionFunctionId ::= "operator" conversionTypeId
conversionTypeId ::= typeSpecifierSeq conversionDeclarator?
conversionDeclarator ::= ptrOperator conversionDeclarator?
ctorInitializer ::= ':' memInitializetList
memInitializetList ::= (memInitializer "..."? ',')* memInitializer "..."?
memInitializer ::= memInitializerId '(' expressionList ')' | memInitializerId bracedInitList
memInitializerId ::= classOrDeclType | identifier
operatorFunctionId ::= "operator" overloadableOperator ('<' templateArgumentList? '>')?
overloadableOperator ::= "new" | "delete" | "new [ ]" | "delete [ ]" | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | "()" | "[]"
literatOperatorId ::= "operator" '"' '"' identifier
templateDeclaration ::= "template" '<' templateParameterList '>' declaration
templateParameterList ::= (templateParameter ',')* templateParameter
templateParameter ::= typeParameter | parameterDeclaration
typeParameter ::= ("class" | "typename" | "template" "<" templateParameterList ">" "class") (identifier? '=' typeId | '...'? identifier?)
simpleTemplateId ::= templateName '<' templateArgumentList '>'
templateId ::= simpleTemplateId | operatorFunctionId "<" templateArgumentList? ">" | literatOperatorId "<" templateArgumentList? ">"
templateName ::= identifier
templateArgumentList ::= (templateArgument "..."?)* templateArgument "..."?
templateArgument ::= constantExpression | typeId | idExpression
typeNameSpecifier ::= "typename" "::"? nestedNameSpecifier (identifier | "template"? simpleTemplateId)
explicitInstantiation ::= "extern"? "template" declaration
explicitSpecialization ::= "template" '<' '>' declaration
tryBlock ::= "try" compoundStatement handlerSeq
functionTryBlock ::= "try" ctorInitializer? compoundStatement handlerSeq
handlerSeq ::= handler*
handler ::= "catch" '(' exceptionDeclaration ')' compoundStatement
exceptionDeclaration ::= "..." | attributeSpecifierSeq? typeSpecifierSeq (declarator | abstractDeclarator?)
throwExpression ::= "throw" assignmentExpression?
exceptionSpecification ::= dynamicExceptionSpecification | noExceptSpecification
dynamicExceptionSpecification ::= "throw" '(' typeIdList? ')'
typeIdList ::= (typeId "..."? ',')* typeId "..."?
noExceptSpecification ::= "noexcept" ('(' constantExpression ')')?
preProcessingFile ::= group
group ::= groupPart* groupPart
groupPart ::= ifSection | controlLine | textLine | "#" nonDirective
ifSection ::= ifGroup elifGroups? elseGroup? endIfLine
ifGroup ::= ("#""if" constantExpression | "#""ifdef" identifier | "#""ifndef" identifier) NEWLINE group?
elifGroups ::= elifGroup* elifGroup
elifGroup ::= "#""elif" constantExpression NEWLINE group?
elseGroup ::= "#""else" NEWLINE group?
endIfLine ::= "#""endif" NEWLINE
controlLine ::= "#""include" ppTokens NEWLINE | "#""define" identifier replacementList NEWLINE | "#" "define" identifier lparen identifierList? ')' replacementList NEWLINE | "#" "define" identifier lparen identifierList ',' '...' ')' replacementList NEWLINE | "#" "undef" identifier NEWLINE | "#" "line" ppTokens NEWLINE | "#" "error" ppTokens? NEWLINE | "#" "pragma" ppTokens? NEWLINE | "#" NEWLINE
textLine ::= ppTokens? NEWLINE
nonDirective ::= ppTokens NEWLINE
lparen ::= '(' //but not " ("
identifierList ::= (identifier ',')* identifier
replacementList ::= ppTokens?
ppTokens ::= preProcessingToken* preProcessingToken
NEWLINE ::= CRLF






